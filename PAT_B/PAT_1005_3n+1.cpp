//  Guess Number from 3*n+1 -> 1
//  Go ahead
//  这种解法（22/25） 最后一个测试点过不去 
//  上述问题已经解决，在代码 47行，48行给出了部分解释 
/*
当我们验证卡拉兹猜想的时候，为了避免重复计算，
可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，
我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，
就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，
因为这 4 个数已经在验证3的时候遇到过了，
我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，
如果 n 不能被数列中的其他数字所覆盖。
现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，
就可以不必再重复验证余下的数字。
你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。
*/

# include <stdio.h>

int main(void)
{
	int k;  // 输入一个整数 k<100
	int n, temp;
	int i;
	int table[101] = {0};  //  记录数据是否出现  (不用再单独排序)
	// 定义为300 不会出现数组越界的情况 
	int val = 0; // 记录 最终table 中有多少个不为零的数 
	
	scanf("%d",&k);
	for (i=0; i<k; i++)
	{
		scanf("%d",&temp);
		table[temp] = 1;
	}
	
	for (i=1; i<=100; i++)
	{
		//  如果此数字在table中出现过，则进行运算 
		if (1 == table[i]) 
		{
			n = i;
			while(n>1)
			{
				if (n%2 == 0)
					n = n/2;
				else
					n = ((3*n)+1)/2; 
// 如果此处写 n = 3*n+1 则会在最后一个测试点无法通过，没有仔细的看数字猜想过程，（3*n+1）/2 
				//  判断计算过程中的数是否在输入数组中出现	
				
				//  注：在提交过程中 如果直接判断 table[n] （n==100）可能会出现数组越界的情况 
				if (n<=100 && n>=2)
				{
					table[n] = 0;
				}
					
			}
				
		}
	}

	//  输出table中不为0 的下标的个数 
	for (i=100; i>=1; i--) 
	{
		if (1 == table[i]) 	
			val++; 
	}
	
	for (i=100; i>=1;  i--)
	{
		if (1==table[i])
		{
			printf("%d",i);
			val--;
			if (val != 0)
				printf(" ");
		}
		
	}
	return 0;
}
